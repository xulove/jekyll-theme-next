# 一、密码学

## 1.1 hash散列原理

> 目标：我们的目标就是用结构体完成一个在程序中使用的Map

### 1.1.1 首先我们来完成一个链表

目录结构如下

```go
src

——MyHashMap

————HashMp //文件夹

		——MyHashMap.go  //文件

————LinkNodes  //文件夹

		——Node.go

————main.go  //文件

```

> Node.go 文件为我们存储了一个节点链。每一个节点我们都用一个结构体来展示。然后我们提供了一些方法，提供了节点的增删改查

```go
package LinkNodes

import (
	"fmt"
)
//声明全局变量，保存头结点
var head *Node
var curr *Node

//声明节点类型
type Node struct {
	//数据域
	Data string
	//地址域
	NextNode *Node
}

//创建头结点
func CreateHeadNode(data string) *Node {
	var node *Node = new(Node)
	node.Data = data
	node.NextNode = nil
	//保存头结点
	head = node
	curr = node
	return node
}

//添加新节点
func AddNode(data string) *Node {
	var newNode *Node = new(Node)
	newNode.Data = data
	newNode.NextNode = nil
	//挂接节点
	curr.NextNode = newNode
	curr = newNode
	//返回值
	return newNode
}

//遍历链表
func ShowNodes() {
	var node = head
	for {
		if node.NextNode == nil {
			fmt.Print(node.Data)
			break
		} else {
			fmt.Println(node.Data)
			node = node.NextNode
		}
	}
}

//计算节点的个数
func NodeCnt() int {
	var cnt int = 1
	var node = head
	for {
		if node.NextNode == nil {
			break
		} else {
			node = node.NextNode
			cnt = cnt + 1
		}
	}
	return cnt
}

//插入节点
func InsertNodeByIndex(index int, data string) *Node {
	if index == 0 {
		//添加的为新的头节点
		var node *Node = new(Node)
		node.Data = data
		node.NextNode = head
		head = node
	} else if index > NodeCnt()-1 {
		//添加节点
		AddNode(data)
	} else {
		//中间插入节点
		var n = head
		for i := 0; i < index-1; i++ {
			n = n.NextNode
		}
		var newNode *Node = new(Node)
		newNode.Data = data
		newNode.NextNode = n.NextNode
		n.NextNode = newNode
	}
	return nil

}

//删除节点
func DeleteNodeByIndex(index int) {

	var node = head
	if index == 0 {
		//删除头节点，就是第二个节点为头结点
		head = node.NextNode
	} else {
		for i := 0; i < index-1; i++ {
			node = node.NextNode
		}
		node.NextNode = node.NextNode.NextNode
	}
}

//修改指定下标的节点内容
func UpdateNodeByIndex(index int, data string) {
	var node = head
	if index == 0 {
		head.Data = data
	} else {

		for i := 0; i < index; i++ {
			node = node.NextNode
		}
		node.Data = data
	}

}
```

> MyHashMap.go这个文件主要是为我们提供了一个方法，我们初始化一个数组，每一个数组的节点都会存储一个节点，也就是头节点。比如我们的数组长度是16,那么我们就有了16个头节点，我们以后增加节点的情况下，就会在这16个头节点下增加。也就是形成了16个链表。

```go
package HashMp

import (
	"MyHashMap/LinkNodes"
)

func CreateBulet() [16]*LinkNodes.Node {

	var arr = [16]*LinkNodes.Node{}
	for i := 0; i < 16; i++ {
		arr[i] = LinkNodes.CreateHeadNode("头节点")

	}
	return arr
}
```

> main.go主要是调用或者测试一下

```
// MyHashMap project main.go
package main

import (
	"MyHashMap/LinkNodes"
	"fmt"
)

func main() {
	fmt.Println("Hello World!")
	//创建头结点
	LinkNodes.CreateHeadNode("头结点")
	LinkNodes.AddNode("第二节点")
	LinkNodes.AddNode("第三节点")
	LinkNodes.AddNode("第四节点")
	//LinkNodes.InsertNodeByIndex(3, "新节点")
	//LinkNodes.DeleteNodeByIndex(3)
	LinkNodes.UpdateNodeByIndex(1, "abc")
	LinkNodes.ShowNodes()
	fmt.Println(LinkNodes.NodeCnt())
}
```

### 1.1.2  接下来我们完成一个hash链表（也就是程序中我们使用的map）

> 文件结构还是相同的，我们主要使用到了hash散列。把每一个key散列到数组中

> MyHashMap.go

```go
package HashMP

import (
	"xu.com/learngo/0515/myHash/linkNodes"
	"fmt"
)
//声明全局数组
var bultArr [16]*linkNodes.Node

//给数组初始化
func CreateBulet()  {
	var arr = [16]*linkNodes.Node{}
	for i := 0; i < 16; i++ {
		arr[i] = linkNodes.CreateHeadNode("头节点","头节点")
	}

	bultArr = arr
}

//将key转换成数组下标的散列算法
func HashCode(key string) int {
	var index int = 0
	index = int(key[0])
	for k := 0; k < len(key); k++ {
		index *= (1103515245 + int(key[k]))   //1103515245：这是16单元的散列因子
	}
	index >>= 27
	index &= 16 - 1

	return index
}
//向数组中添加键值对
func AddKeyValue(k string,v string){
	//计算键所对应的木桶下标
	var pos = HashCode(k)
	//获得木桶数组
	//var arr = CreateBulet()
	var head *linkNodes.Node = bultArr[pos]
	//向指定下标的头节点添加节点
	linkNodes.AddNode(k,v,head)
}

//获取数据
func GetValueByKey(k string)string{
	var pos = HashCode(k)
	var head *linkNodes.Node = bultArr[pos]
	//通过头节点遍历链表
	//linkNodes.ShowNodes(head)
	//查找对应下标下的链表，判断在key与节点中的key一致时打印
	for {
		if head.Data.K == k {
			fmt.Println(head.Data.V)
			break
		}else{
			head =head.NextNode
			if head.NextNode == nil {

			}
		}
	}

	return ""
}
```

> Node.go

```go
package linkNodes

import "fmt"
//用结构体作为数据域的类型
type DM struct {
	K string
	V string
}

//声明全局变量，保存头节点
var head *Node
var curr *Node

//声明节点类型
type Node struct {
	//数据域
	Data DM
	//地址域
	NextNode *Node
}

//创建头节点
func CreateHeadNode(k string,v string)*Node{
	var node *Node= new(Node)
	//设置数据域结构体中的键值对
	node.Data.K = k
	node.Data.V = v
	//设置地址域
	node.NextNode=nil

	//保存头节点
	head = node
	curr=head //把当前节点的指针指向头节点
	return node;
}

//在指定的节点的后面添加新节点
func AddNode(k string,v string,curr *Node) *Node {
	var newNode *Node = new(Node)
	//设置新节点中的数据域
	newNode.Data.K = k
	newNode.Data.V = v
	//设置地址域
	newNode.NextNode = nil

	//挂接节点
	curr.NextNode = newNode
	curr = newNode

	return newNode
}

//在指定的节点后面遍历链表
func ShowNodes(n *Node){
	var node = n
	for {
		if node.NextNode == nil {
			fmt.Println(node.Data)
			break
		}else{
			fmt.Println(node.Data)
			node = node.NextNode
		}
	}
}
//计算节点的个数
func NodeCnt()int{
	var num = 1;
	var node = head
	for {
		if node.NextNode == nil {
			break
		}else{
			node = node.NextNode
			num += 1
		}
	}
	return num
}
//插入节点
/*
func InsertNodeByIndex(index int,data string) *Node{

	if index==0 {
		//添加的节点为头节点
		var node *Node=new(Node)
		node.Data = data
		node.NextNode = head
		head = node
	}else if index > NodeCnt()-1 {
		//最后添加一个节点即可
		AddNode(data)
	}else{
		//中间插入节点
		var n = head
		for i:=0;i < index-1;i++{
			n = n.NextNode
		}

		var newNode *Node = new(Node);
		newNode.Data = data
		newNode.NextNode = n.NextNode
		n.NextNode = newNode
	}
	return nil
}
*/

//删除节点
/*
func DeleteNodeByIndex(index int){
	var node = head
	if index==0 {
		//删除头节点，就是让第二个节点当头节点
		head = node.NextNode
	}else{
		for i := 0; i < index-1; i++ {
			node = node.NextNode
		}
		node.NextNode = node.NextNode.NextNode
	}
}
*/

// 修改
/*
func UpdateNodeByIndex(index int,data string){
	var node = head

	if index == 0 {
		head.Data = data
	}else{
		for i:=0;i<index;i++{
			node = node.NextNode
		}
		node.Data = data
	}

}
*/
```

> main.go

```go
package main

import (
	"fmt"
	"xu.com/learngo/0515/myHash/HashMP"
)

func main() {
	fmt.Println("hello world")

	//测试HashMP包下面的散列因子
	//fmt.Println(HashMP.HashCode("abc"))

	HashMP.CreateBulet()

	HashMP.AddKeyValue("abc","hello")
	HashMP.AddKeyValue("bcd","world")

	HashMP.GetValueByKey("abc")

}

```

### 1.1.3 加密算法

#### 1.1.3.1 MD5加密和sha256加密

```go
package main

import (
   "fmt"
   "crypto/sha256"
   "os"
   "io"
   "crypto/md5"
   "encoding/hex"
)

func main() {
   //什么是明文，什么是密文，什么是密钥
   var a = 111;

   fmt.Println(a%7 ^ 5);

   //通过乘法hash对helloworld进行加密
   fmt.Println(bernstein("hello world"))
   MySha256()

   MyIOSha256()

   //md5加密
   MyMd5()

}

//标准的hash算法
func  bernstein(key string)int{
   var hash int;
   for i:=0;i< len(key); i++ {
      hash = 33*hash + int(key[i]);
   }
   return hash;
}
//go中sha256算法,调用自带的sha256的库
func MySha256(){
   //方法一
   sum:=sha256.Sum256([]byte("hello world"))
   fmt.Printf("%x\n",sum)

   //方法二
   h:=sha256.New()
   h.Write([]byte("hello world"))
   fmt.Printf("%x\n",h.Sum(nil))
}

//将文件中内容做256加密
func MyIOSha256(){
   f,_:=os.Open("text");
   defer f.Close()
   h:=sha256.New()
   io.Copy(h,f)
   fmt.Printf("%x\n",h.Sum(nil))

}
//调用go环境自带的MD5
func MyMd5(){
   fmt.Println("md5加密")
   //方法一
   data:=[]byte("hello worlld")
   s:=fmt.Sprintf("%x",md5.Sum(data))
   fmt.Println(s)
   //方法二
   h:=md5.New()
   h.Write(data)
   s=hex.EncodeToString(h.Sum(nil))
   fmt.Println(s)
}
```

