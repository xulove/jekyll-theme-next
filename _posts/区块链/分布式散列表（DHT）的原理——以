GFW:导致【彻底无中心】的分布式系统非常有用

DHT：分布式散列表。是分布式系统的【关键基础设施】

哈希/散列/hash

散列表（hash table）
	一种存储键值对的容器
如何实现散列表：
	1.计算散列值
	2.计算桶编号
什么是“散列表”和碰撞/冲突（Collosion）？
	1.散列值直接相同
	2.散列值不同，但是取模运算后桶编号相同
散列表的优点
-------------------------

分布式散列表【DHT】
	传统的散列表：用于单机上的某个软件中
	分布式散列表：用户分布式系统中（分布式系统的节点可以通俗的理解为散列表的Bucket）

p2p文件共享的历史：
	第一代：中央服务器  问题：单点故障
	第二代：广播	问题：广播风暴
	第三代：DHT

分布式散列表的难点：
	1.无中心导致的难点
		增加了一系列复杂实现机制
	2.海量数据导致的难点
		数据均摊困难
	3.节点动态变化
		依然要保证数据均摊
		传统散列表是不能动态变化的
	4.高效查询难点

分布式散列表【DHT】如何解决上述问题？
	1.散列算法的选择
	2.同构node ID 和 data key 
	3.拓朴结构的设计
		有了拓朴结构，自然要设计 路由算法
		key-based routing : key本身已经提供了足够多的路由信息
	
		覆盖网络

路由算法 的权衡
	每个节点通常只知道少数一些节点的信息
	
	路由算法：
		利用已知的节点转发数据
		路由表的大小
距离算法：
	节点之间的距离，数据之间的距离，节点与数据的距离
	逻辑层面的距离，对应DHT自己的拓朴结构
	nodeID和data key同构，就可以使用同一种距离算法

数据定位;
	保存数据
	获取数据
		都是先计算自己与数据key之间的距离

-----------------------------------------

Chord 协议简介
概述：
	第一批DHT协议
拓朴结构-环形
	一致散列/稳定散列
	nodeID和data key同构的话，他们都可以映射到稳定散列环上。
	继任和前任
		数据隶属【距离最小】的节点
	Chord用的就是 “一致性散列”的拓朴结构

路由机制：
	基本路由：
	——收到请求（key），先看key是否在自己这里。在->返会，不在->将key转发给继任者。
	高级路由：
	——根据Finger Table判断把key应该直接发给谁？

节点的加入：
	1.节点A加入系统-和任一节点B建立链接
	2.A生成ID
	3.通过B找到自己的继任C和前任D。
	4.A和C、D互动，是自己成为C的前任，D的继任
	A和C、D互动的过程，就是向链表中插入元素的过程。

节点的【正常】退出
	需要跟自己的继任和前任沟通交互，大致类似于链表中的删除元素

节点的【异常退出】
	“继任者候选列表”，自己的继任者没了，自己还保存好多候选继任者。
	A也会沟通自己的前任，让前任更新自己的“继任者候选列表”
----------------------------------------------------------
----------------------------------------------------------

                        Kad协议
----------------------------------------------------------
----------------------------------------------------------
概述：
	Kad使用最为广泛
拓朴结构-二叉树
	散列值预处理：
		nodeID和data key同构
		把key映射到一个二叉树，每一个key都是这个二叉树的叶子
		
		key用二进制形式表示->每个key缩短为它的【最短唯一前缀】
	最短唯一前缀：
		kad的散列算法，会导致keyspace很大-> 任何两个key的【距离】都不会非常临近。
		而使用“最短唯一前缀”处理key后，得到的结果key的距离会很短。
	散列值的映射：
		1.key用二进制表示，从高位到低位依次处理
		2.二进制的第n位，就对应二叉树的第n层
		3.如果该位置是1，进入左子树。如果是0，进入右子树。（自己规定就可以）
		4.全部处理完后，这个key就对应二叉树的某个。
	
	距离算法-异或（XOR）：kad的最精妙之处
		采用XOR（比特异或操作）计算key之间的距离
			两数相同，异或为0；两数不同，异或为1.
		这样就有了“几何距离”的特性
路由机制：
	二叉树的拆分：
	K-桶（K-bucket）
		K-桶其实就是路由表
节点的加入：
	通过其中的任一节点建立连接

节点的退出：
	不需要有任何操作
-------------------------------------------
Kad为什么能成为主流？
	灵活性：K值可以调整
	性能：Kad的路由算法天生支持【并发】
	安全性：
		攻击难度大
	
		
			
